# 「Reactとは？」と説明するために
以下について自分の言葉で説明して理解する。
- そもそもDOMって何？
- ブラウザにページ表示されるまでの流れ(DOM・DOM tree・Render tree)
- 仮想DOM
- React

### **総括**
DOM
- DOM = **HTML/XMLファイルを操作するためのAPI**/ライブラリ。
- HTML/XMLをパースした結果をメモリ上に DOM tree として構築。
- このDOM treeに対して、API(DOM)で操作する。
- **DOM treeはメモリ上のデータ**なので、物理的な元のファイルに対してAPI(DOM)で操作するわけではない。<br>

仮想DOM
- メモリ上にあるDOM treeを、**JavaScriptのプログラム上でJSオブジェクトとして表現したもの**。
<br>

React
- **UI構築用のJavaScriptライブラリ**。
- 以下の特徴をもつ。<br>
1. Component -> 再利用できる。<br>
2. 仮想DOM -> Renderingパフォーマンス工場<br>
3. JSX -> コーディングしやすい。

# そもそもDOMって何？
- The Document Object Model (DOM) is a programming **API for HTML and XML** documents. from [公式ドキュメント](https://www.w3.org/TR/WD-DOM/introduction.html)
- DOMとは**HTML/XMLファイルをプログラム経由で操作するためのAPI**<br>
・HTML：Webページ表示用のマークアップ言語<br>
・XML：データ記述用のマークアップ言語
- **パース結果のDOM treeに対してAPI(DOM)で操作する = 元の物体ファイルはいじらない。**
- DOM自体は「Document(HTML/XML)を操作するAPI」なので、**ブラウザとは関係ないプログラム上でも使うことができるもの、XMLをDOMで操作するときとかまさに。**(ブラウザ/HTML/DOMのイメージが強いのであえて記述する。)
- **各言語でDOMというAPI(IF)が実装されている。IFだから。**<br>
・JavaScript -> 標準ライブラリとしてDOM(API)が使える。例: `document`インタフェース<br>
・Python -> [xml.dom](https://docs.python.org/ja/3/library/xml.dom.html)が提供されている。

# ブラウザにページ表示されるまでの流れ(DOM・DOM tree・Render tree)
1. まずHTMLがパースされてメモリ上に DOM tree が構築される。
2. CSSはまた別のパーサでパースされて Style rules が構築される。
3. 1で作られたメモリ上の DOM tree は DOM(API)で操作/参照可能。
4. DOM tree + Style rules = Render tree ..これが画面表示するためのINPUTとなる。
5. DOM(API) -> DOM treeを更新 -> Render Treeに反映 -> 画面に反映 という流れ。

<img width="700px" src="https://storage.googleapis.com/zenn-user-upload/4c3dc9e655e0-20230729.png" />

参考：[web.dev｜How browsers work](https://web.dev/howbrowserswork/#main-flow-examples)

# 仮想DOM
仮想DOMとは
- メモリ上にあるDOM treeを、JavaScriptのプログラム内のオブジェクトとして表現したもの。
- The Virtual DOM is **A JavaScript representation of the actual DOM**.
- A lightweight JavaScript object.
- A replica of the original DOM.

なぜ**実DOMとは別でもう１つ**JavaScriptで表現されたDOM(仮想DOM)を用意するのか？
- 🔴**実DOM更新によるレンダリングコストを下げるため/For performance**
- 実DOMの変更はDOMツリー全体をレンダリングするのでCost高い。
- 従来のJQuery等のやり方だと、実DOMを毎回更新してレンダリングコストが高い。
- **更新が必要なところだけレンダリングし直せたら--->仮想DOMを使って実現。**

仮想DOMをつかってページ表示を行う仕組み

```md
# 初回ページ表示
1. HTML -> パース -> 実DOM tree構築
2. JS実行【UIライブラリ(React) -> 仮想DOM構築】 **Renderフェーズ**
3. 仮想DOM構築完了 -> DOM(API)経由 -> 実DOMへ反映 **Commitフェーズ**
```
```md
# 別ページへ遷移
4. 別ページへ遷移 -> 仮想DOM再構築(ComponentのMount/Unmount) **Renderフェーズ**
5. 仮想DOM構築完了 -> DOM(API)経由 -> 実DOMへ反映 **Commitフェーズ**
```
```md
# 同ページ内で更新処理(User操作/APIレスポンス画面表示)
6. 更新処理 -> 仮想DOM再構築(ComponentのMount/Unmount) **Renderフェーズ**
7. 仮想DOM構築完了 -> DOM(API)経由 -> 実DOMへ反映 **Commitフェーズ**
```
# 何度も行われるRenderフェーズで呼び出される可能性があるところ
以下を題材にする。
```tsx
import { capitalize } from '@/utils/stringUtils';
import { useEffect, useRef } from 'react';
import { Typography } from '@/components/Typography';
import styles from './Snackbar.module.css';

export type SnackbarProps = {
    open: boolean;
    type: 'success' | 'error';
    message: string;
};

export const Snackbar = (props: SnackbarProps) => {
    const { open, type, message } = props;

    // useRef = DOMを直接操作したい時に使う。
    const popoverRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const popoverElem = popoverRef.current;
        // commit完了前はnullなのでreturn
        if (popoverElem === null) return;

        if (open) {
            if (!popoverElem.matches(':popover-open')) popoverElem.showPopover();
        } else {
            if (popoverElem.matches(':popover-open')) popoverElem.hidePopover();
        }
    }, [open]);

    return (
        <div
            // 手動(JavaScript)で開閉する（通常はpopovertaget属性で自動）
            popover="manual"
            ref={popoverRef}
            className={styles.root}
        >
            <div className={`${styles.content} ${styles[`${type}Style`]}`}>
                <img src={`/svg/white${capitalize(type)}.svg`} height="20px" />
                <Typography tag="p">{message}</Typography>
            </div>
        </div>
    );
};
```

具体的には次のことが毎回の Render で行われる。

## 1. props の分割代入
→ これは普通の JS の式なので、毎回評価される
```tsx
const { open, type, message } = props;
```

## 2. useRef 呼び出し
→ 新しいオブジェクトは作らず、前のレンダリングで作成した既存の ref オブジェクトを返す<br/>
→ 返すだけなのでレンダリングの「仮想DOMへの影響」はない
```tsx
const popoverRef = useRef<HTMLDivElement>(null);
```

## 3. useEffect の認識(実行はしない)
→ Render フェーズでは 実行されない。<br/>
→ Commit フェーズで実行されるため、Render では単に「この副作用を登録した」とだけ React が覚える。
```tsx
useEffect(() => { ... }, [open]);
```

## 4. return の JSX
→ これが 実際の仮想DOMを構築する部分<br/>
→ 毎回のレンダリングで再評価され、仮想DOMが作られる対象になる<br/>
→ `<div>`, `<img>`, `<Typography>` などの仮想ノード
```tsx
return (
    <div ...>
        ...
    </div>
);
```


# React
React
- **UI構築用のJavaScriptライブラリ**
- A JavaScript library that is used for building user interfaces.
- **仮想DOMを採用しているので、UIの更新を効率的にできる。**
-　コンポーネントを使ってコーディングできる -> simple and easier to maintain

なぜReactを使うのか
- Reusable Components
- Virtual DOM
- JSX
- Redux
- React Hooks

Refer: [Why Use React? – Top 8 Reasons Experts Use React in 2023](https://www.monocubed.com/blog/why-use-react/)
