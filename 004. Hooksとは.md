# まず一言でいうと

フック（Hook）とは
```
👉 「関数コンポーネントに、Reactの機能（状態・ライフサイクル・文脈など）を“引っかける”ための仕組み」
```

クラスコンポーネントでできていたことを、関数コンポーネントでもできるようにしたAPI、それがフック。

# なんで「フック」って名前？
Reactコンポーネントの内部処理に、決まったタイミングで“割り込む（hookする）" から。

# useEffect = "副作用"を登録する。
useEffectは「副作用をコンポーネントに登録(フック)する」という感覚。

# useState = "状態"を登録する
useStateは「状態をコンポーネントに登録(フック)する」という感覚。

# useRef = "レンダリングとは独立した箱"を登録する
※[Reactのレンダリング](https://github.com/daisuketakakuwa/react-learning/blob/main/003.%20React%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0.md)における「Renderフェーズ」「Commitフェーズ」を前提※

✅Renderフェーズ中に `useRef` を呼んでも 新しいオブジェクトは作られない。<br/>
✅React は 前回保持していた `ref` オブジェクトを返す。<br/>
✅つまり、レンダリングのたびに 同じ箱が返される<br/>
　　→ レンダリングと無関係に「状態を持てる」

# useCallback = "必要なときだけ再生成させたい関数"を登録する
- 通常、コンポーネント内で定義された関数はコンポーネントが**再レンダリングされるたびに新しく作られる**
- 別に毎回作られても問題ないものはあるし、それらは毎回作られるでOK。
- しかし `document.addEventListener`に登録する関数が毎回再生成されるのは困る...というケースがある。
- その時に`useCallbacK`を使って「メモ化したい関数」を登録する。

## 関数が毎回作られると困るパターンは？
### 1. `document.addEventListener`はuseEffectで1回だけ実行させたい -> 登録する関数も必要なタイミングだけ生成させたい。
```tsx
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);

useEffect(() => {
  document.addEventListener("click", handleClick);
  return () => document.removeEventListener("click", handleClick);
}, [handleClick]);
```

### 2. （超王道）子コンポーネントにpropsで渡す関数を不要に再生成させないように。
↓コードの問題点
- Parent が再レンダリングされるたびに
- handleClick が新しい関数になる
- Child は props が変わったと判断 → 再レンダリング
```tsx
const Parent = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    console.log("clicked");
  };

  return <Child onClick={handleClick} />;
};
```

## 関数だけど別に毎回再生成されてもいいパターン
### コンポーネント内でしか使わない関数
```tsx
const handleClick = () => {
  setCount(c => c + 1);
};
```







